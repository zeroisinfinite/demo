/**!
 * alibaba buc sso
 *
 * Copyright(c) 2012 - 2014 Alibaba Group Holding Limited.
 * Authors:
 *   tangyao <tangyao@taobao.com>,
 *   suqian.yf <suqian.yf@taobao.com>
 */

"use strict";

/**
 * Module dependencies.
 */

var userauth = require('userauth');
var urllib = require('urllib');
var urlparse = require('url').parse;
var debug = require('debug')('node-buc');
var fs = require('fs');
var path = require('path');

var SSO_SERVER = "https://login-test.alibaba-inc.com";//https://10.20.159.92
var CLIENT_VERSION = '0.3.7';
var CHECK_TOKEN_URL = '';
var RPC_TIMEOUT = 5000;

var CHECK_SSO_TOKEN_URL = '';

/**
 * Create buc user auth middleware.
 * BUC doc: http://docs.alibaba-inc.com/display/RC/Buc+SSO+USER+GUIDE
 *
 * @param {Regex|Function(pathname, req)} match, detect which url need to check user auth.
 * @param {Object} options
 *  - {String} account, buc appname, must provide.
 *  - {String} [server], buc server root url, default is 'https://login-test.alibaba-inc.com'.
 *      You must change it to 'https://login.alibaba-inc.com' on production env.
 *
 *  @see http://docs.alibaba-inc.com/pages/viewpage.action?pageId=107288804
 *  - {Object} [authOptions] 如果你的应用支持 access token 登录, 那么请设置这个参数, 如 阿里内网内嵌应用
 *    - {String} appcode buc分配的 appcode, 如有疑问, 请联系@冰梨
 *    - {String} [tokenField] access token 在 querystring 中的字段名, 默认是 accessToken
 *    - {String} [type] app type, 默认是 app, 可选是 api
 *
 *  - {Number} [timeout], buc rpc communicate request timeout, default is `urllib.TIMEOUT`: 5 seconds.
 *  - {String} [userField], req.session[userField] name, default is 'user'.
 *  - {String} [loginPath], default is '/login'.
 *  - {String} [logoutPath], default is '/logout'.
 *  - {String} [contextPath], custom app url root path, default is '/'.
 *  - {Object} [loginParams], default is empty.
 *   - {String} CANCEL_CERT, if you don't want to use cert login, please set `CANCEL_CERT='true'`.
 *  - {Function(req, user, callback)} [loginCallback], you can handle user login logic here.
 *    - {Function(err, user, redirectURL)} callback
 *  - {Function(req, user, callback)} [logoutCallback], you can handle user logout logic here.
 *    - {Function(err, redirectURL)} callback
 * @return {Function(req, res, next)} middleware
 */
exports = module.exports = function buc(match, options) {
  if (arguments.length === 1) {
    // buc(options);
    options = match;
    match = /^\//; // match all
  }

  options = options || {};

  exports.init(options);

  options.contextPath = options.contextPath || '/';
  if (options.contextPath !== '/') {
    if (!options.rootPath) {
      options.rootPath = options.contextPath;
    }
  }
  options.rootPath = options.rootPath || '/';

  if (!options.account) {
    throw new Error('`options.account` required.');
  }
  if (options.timeout && options.timeout > 0) {
    RPC_TIMEOUT = options.timeout;
  }

  // no need for version update on 0.3.6+
  // var registUrl = SSO_SERVER + '/updateAppVersion.do?APP_NAME=' + encodeURIComponent(options.account) +
  //   '&CLIENT_VERSION=' + encodeURIComponent(CLIENT_VERSION);
  // urllib.request(registUrl, function (err, data) {
  //   debug('%s %s, err: %s', registUrl, data, err);
  // });

  var LOGIN_URL = SSO_SERVER + '/ssoLogin.htm?APP_NAME=' + encodeURIComponent(options.account) +
    '&CLIENT_VERSION=' + encodeURIComponent(CLIENT_VERSION) +
    '&CONTEXT_PATH=' + encodeURIComponent(options.contextPath);
  var LOGOUT_URL = SSO_SERVER + '/ssoLogout.htm?APP_NAME=' + encodeURIComponent(options.account) +
    '&CLIENT_VERSION=' + encodeURIComponent(CLIENT_VERSION) +
    '&CONTEXT_PATH=' + encodeURIComponent(options.contextPath);

  if (options.loginParams) {
    for (var k in options.loginParams) {
      var v = options.loginParams[k];
      LOGIN_URL += '&' + k + '=' + encodeURIComponent(v);
    }
  }
  LOGIN_URL += '&BACK_URL=';

  options.loginCallbackPath = '/sendBucSSOToken.do';

  var authOptions = options.authOptions;
  if (authOptions && authOptions.appcode) {
    authOptions.type = authOptions.type || 'app';
    authOptions.tokenField = authOptions.tokenField || 'accessToken';
    authOptions.ssoTicket = authOptions.ssoTicket || 'SSO_TICKET';
    // login callback remove the access token
    if (!options.loginCallback) {
      options.loginCallback = function (req, user, callback) {
        if (!user.isAccessTokenLogin) {
          return callback(null, user);
        }
        var re = new RegExp(authOptions.tokenField + '=[\\w+\-]+&?');
        var url = req.url.replace(re, '');
        if (url[url.length - 1] === '?') {
          // remove last ?
          url = url.substring(0, url.length - 1);
        }
        callback(null, user, url);
      };
    }
  } else {
    authOptions = null;
  }

  // buc logout
  if (!options.logoutCallback) {
    options.logoutCallback = function bucLogout(req, res, user, cb) {
      var backurl = req.headers.referer;
      if (!backurl) {
        backurl = (options.protocol || 'http') + '://' + (options.host || req.headers.host) + options.rootPath;
      }
      var logoutURL = LOGOUT_URL + '&BACK_URL=' + encodeURIComponent(backurl);
      cb(null, logoutURL);
    };
  }

  options.loginURLForamter = function (url) {
    url = LOGIN_URL + encodeURIComponent(url);
    debug('login url: %s', url);
    return url;
  };

  options.getUser = function (req, callback) {
    var query = req.query;
    if (!query) {
      query = urlparse(req.url, true).query || {};
    }

    var isLoginCallbackURL = req.url.indexOf(options.loginCallbackPath) === 0;

    function getSsoUserHandler (err, user) {
      if (err) {
        err.data = {query: query, data: err.data};
        return callback(err);
      }

      var authUser = null;
      if (user) {
        authUser = {
          userid: user.emailPrefix,
          dep: user.depDesc,
          cname: user.nickNameCn,
          email: user.emailAddr,
          workid: user.empId,
          ssoUser: user
        };
      }
      callback(null, authUser);
    }

    if (!isLoginCallbackURL) {
      // if not login callback url, check access token login
      if (authOptions) {
        var accessToken = query[authOptions.tokenField];
        if (accessToken) {
          var authUrl = SSO_SERVER + '/authorize/validateAccessToken.do'
            + '?type=' + authOptions.type + '&appcode=' + encodeURIComponent(authOptions.appcode)
            + '&accesstoken=' + encodeURIComponent(accessToken);
          exports.checkAccessToken(authUrl, function (err, user) {
            if (err) {
              return callback(err);
            }

            var domainUser = user.DomainUser;
            if (domainUser && domainUser.indexOf('\\') >= 0) {
              domainUser = domainUser.split('\\')[1];
            }
            var nick = (user.DisplayName || '').trim();
            if (nick) {
              nick = new Buffer(nick, 'base64').toString();
              // {陈小刚}({047734})
              if (nick.indexOf('(') > 0) {
                nick = nick.split('(')[0].replace(/[\{\}\(\)]+/g, '');
              }
            }

            var workid = String(user.WorkId);
            workid = workid.replace(/^0+/i, '');

            var authUser = {
              userid: domainUser,
              cname: nick,
              email: user.Email,
              workid: workid,
              ssoUser: user,
              isAccessTokenLogin: true,
            };

            callback(null, authUser);
          });
          return;
        }

        // login with SSO_TICKET
        // Modified 2014.11.10 by shidu.mj@taobao.com

        var ssoTicket = query[authOptions.ssoTicket];
        if (ssoTicket) {
          exports.checkToken({
            appCode: authOptions.appcode,
            token: ssoTicket,
            authUrl: CHECK_SSO_TOKEN_URL
          }, getSsoUserHandler);
          return ;

        }

      }

      return callback();
    }

    var token = query.SSO_TOKEN || query.sso_token;
    if (!token) {
      return callback();
    }

    exports.checkToken({
      token: token,
      authUrl: CHECK_TOKEN_URL,
    }, getSsoUserHandler);
  };
  return userauth(match, options);
};

exports.init = function (options) {
  options = options || {};
  if (options.client_version) {
    CLIENT_VERSION = options.client_version;
  }

  SSO_SERVER = options.server || SSO_SERVER;
  if (SSO_SERVER[SSO_SERVER.length - 1] === '/') {
    SSO_SERVER = SSO_SERVER.substring(0, SSO_SERVER.length - 1);
  }

  CHECK_TOKEN_URL = SSO_SERVER + '/rpc/sso/communicate.json';

  CHECK_SSO_TOKEN_URL = SSO_SERVER + '/rpc/ssoToken/validateSsoToken.json';
};

var ERROR_CODES = {
  1000: '网站出现错误',
  1001: '用户身份过期，请重新登录。',
  1002: '访问请求错误，请重新请求',
  1003: '当前应用不支持证书登录',
  1004: '获取身份错误，人员信息库中没有你的信息',
  1005: '您输入的用户名或密码错误，请重新登录',
  1006: '当前用户没有访问该应用的权限',
  1008: '请求错误，没有带上ticket',
  1009: '请求错误，没有带上secretId',
  1010: '访问请求格式错误，再重新请求。',
  1011: '用户身份信息密钥不存在，请重新登录。',
  1012: '您所访问的应用未向统一登录中心注册',
  1013: '用户身份信息密钥错误，请重新登录。',
  1014: '请求所带参数信息与注册信息不符，请重新请求',
  1015: '请求超时，请重新登录。',
  1100: '登录已过期，请重新登录。',
  1200: 'AppCode非法',
  1201: '请求系统授权失败',
  1202: '请求AccessToken时参数为空',
  1203: 'AuthCode无效',
  1204: 'AuthCode重复使用',
  1205: '请求ValidateAccessToken时参数为空',
  1206: 'AccessToken无效',
  1207: 'AccessToken过期',
  1208: '根据AccessToken取不到UserProfile信息',
  1209: '获取AccessToken的授权方式未在受保护的API中进行授权',
  1210: '获取AccessToken的授权方式低于Api保护的授权',
  1211: '无效的客户端类型',
  1212: 'RefreshAccessToken时参数为空',
  1213: 'RefreshAccessToken时根据AccessToken获取TokenInfo失败',
  1214: 'RefreshToken无效',
  1215: '置换AccessToken时设置缓存失效',
  1216: '请求Login服务时AccessToken无效',
  1217: '请求Login服务时AccessToken对应的UserKey无效',
  1218: '请求DisableToken时参数为空',
  1219: '请求DisableToken时传入的参数无效',
  1300: '请求错误, 在请求验证AccessToken时，参数appcode不能为空(客户端异常)',
  1301: '请求错误, 在请求验证AccessToken时，参数accesstoken不能为空(客户端异常)',
  1302: '请求错误, 验证AccessToken失败(客户端异常)',
  1401: '警告：存在钓鱼行为',
  1402: '警告：存在钓鱼行为，访问的应用与颁发token的应用不一致',
};

exports.checkAccessToken = function (url, callback) {
  var args = {
    dataType: 'json',
    timeout: RPC_TIMEOUT,
  };

  urllib.request(url, args, function (err, data, res) {
    if (err) {
      return callback(err);
    }
    data = data || {};
    if (!data.WorkId) {
      err = new Error(ERROR_CODES[data.ErrorCode] || ('unknow buc error code: ' + data.ErrorCode));
      err.message += '\ncode: ' + data.ErrorCode
        + '\nurl: ' + url
        + '\nresult: ' + JSON.stringify(data)
        + '\nstatusCode: ' + (res && res.statusCode);
      debug('checkAccessToken error: %s', err.message);
      return callback(err);
    }

    debug('checkAccessToken %s, got %j', url, data);
    callback(null, data);
  });
};

exports.checkToken = function (options, callback) {
  var args = {
    type: 'POST',
    dataType: 'json',
    timeout: RPC_TIMEOUT,
    data: {
      RETURN_USER: 'true',
      SSO_TOKEN: options.token,
    }
  };

  // add param APP_CODE
  if (options.appCode) {
    args.data.APP_CODE = options.appCode;
  }

  urllib.request(options.authUrl, args, function (err, data, res) {
    if (err) {
      if (err.name === 'SyntaxError') {
        err.name = 'BucUserFormatError';
      } else {
        err.name = 'Buc' + err.name;
      }
      if (Buffer.isBuffer(data)) {
        data = data.toString();
      }
      err.data = {req: args.data, res: data || null};
      return callback(err);
    }

    debug('checkToken, %s: %j, %j', options.authUrl, args, data);
    data = data || {};
    var user = data.content;

    // {"content":"{\"havanaId\":\"1095220781260\",...}","hasError":false}
    // {"errors":[{"code":"rpc_invalid_arg","field":"RETURN_USER","msg":"can't convert '' to boolean for field 'RETURN_USER'"}],"hasError":true}

    if (user) {
      try {
        user = JSON.parse(user);
      } catch (err) {
        err.name = 'BucUserFormatError';
        err.data = {req: args.data, res: data};
        return callback(err);
      }
    }

    if (!user) {
      var errors = data.errors;
      if (errors && errors[0]) {
        var e = errors[0];
        err = new Error(e.msg || 'Buc server response error, code: ' + e.code);
        err.name = 'BucRPCError';
      } else {
        err = new Error('User not found from sso server');
        err.name = 'BucUserNotFoundError';
      }
    } else if (user.errorMessage) {
      err = new Error(user.errorMessage);
      err.name = 'BucRPCClientError';
    }

    if (err) {
      err.data = {req: args.data, res: data};
      return callback(err);
    }

    callback(null, user);
  });
};

exports.CLIENT_VERSION = CLIENT_VERSION;
